
import { NextRequest } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { cookies } from 'next/headers';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

// Fun√ß√£o para enriquecer um lead com todos os dados relacionados
async function enriquecerLead(lead: any, baseUrl: string, funis: any[], estagiosPorFunil: Record<string, any[]>, parceiros: any[], userId: number) {
  try {
    // Buscar funil e est√°gio
    const funil = funis.find((f: any) => f.CODFUNIL === lead.CODFUNIL);
    const estagios = estagiosPorFunil[lead.CODFUNIL] || [];
    const estagio = estagios.find((e: any) => e.CODESTAGIO === lead.CODESTAGIO);

    // Buscar parceiro
    const parceiro = parceiros.find((p: any) => p.CODPARC === lead.CODPARC);

    // Headers com autentica√ß√£o
    const headers = {
      'Cookie': `user=${JSON.stringify({ id: userId })}`
    };

    // Buscar atividades do lead
    const atividadesResponse = await fetch(`${baseUrl}/api/leads/atividades?codLead=${lead.CODLEAD}`, { headers });
    const atividades = atividadesResponse.ok ? await atividadesResponse.json() : [];

    // Buscar produtos do lead
    const produtosResponse = await fetch(`${baseUrl}/api/leads/produtos?codLead=${lead.CODLEAD}`, { headers });
    const produtosLead = produtosResponse.ok ? await produtosResponse.json() : [];

    // Buscar pedidos do parceiro (se houver)
    let pedidosParceiro = [];
    if (parceiro?.CODPARC) {
      const pedidosResponse = await fetch(`${baseUrl}/api/sankhya/pedidos/listar?codParc=${parceiro.CODPARC}&userId=${userId}`, { headers });
      pedidosParceiro = pedidosResponse.ok ? await pedidosResponse.json() : [];
    }

    // √öltima intera√ß√£o
    const atividadesOrdenadas = [...atividades].sort((a, b) => 
      new Date(b.DATA_HORA).getTime() - new Date(a.DATA_HORA).getTime()
    );
    const ultimaAtividade = atividadesOrdenadas[0];

    return {
      ...lead,
      // Funil e est√°gio
      NOME_FUNIL: funil?.NOME || 'Funil Desconhecido',
      COR_FUNIL: funil?.COR || '#gray',
      NOME_ESTAGIO: estagio?.NOME || 'Est√°gio Desconhecido',
      ORDEM_ESTAGIO: estagio?.ORDEM || 0,
      COR_ESTAGIO: estagio?.COR || '#gray',
      ESTAGIOS_FUNIL: estagios.map((e: any) => ({
        nome: e.NOME,
        ordem: e.ORDEM,
        cor: e.COR
      })),
      // Parceiro
      PARCEIRO: parceiro ? {
        codigo: parceiro.CODPARC,
        nome: parceiro.NOMEPARC,
        documento: parceiro.CGC_CPF,
        cidade: parceiro.NOMECID,
        ativo: parceiro.ATIVO
      } : null,
      // Produtos vinculados
      PRODUTOS: produtosLead.filter((p: any) => p.ATIVO === 'S').map((p: any) => ({
        codigo: p.CODPROD,
        descricao: p.DESCRPROD,
        quantidade: p.QUANTIDADE,
        valorUnitario: p.VLRUNIT,
        valorTotal: p.VLRTOTAL
      })),
      // Atividades
      ATIVIDADES: atividades.map((a: any) => ({
        tipo: a.TIPO,
        descricao: a.DESCRICAO,
        dataHora: a.DATA_HORA,
        status: a.STATUS,
        cor: a.COR
      })),
      // √öltima intera√ß√£o
      ULTIMA_INTERACAO: ultimaAtividade ? {
        data: ultimaAtividade.DATA_HORA,
        tipo: ultimaAtividade.TIPO,
        descricao: ultimaAtividade.DESCRICAO
      } : null,
      // Pedidos do parceiro
      PEDIDOS_PARCEIRO: pedidosParceiro.slice(0, 5).map((p: any) => ({
        nunota: p.NUNOTA,
        valor: p.VLRNOTA,
        data: p.DTNEG,
        vendedor: p.NOMEVEND
      }))
    };
  } catch (error) {
    console.error(`Erro ao enriquecer lead ${lead.CODLEAD}:`, error);
    return lead;
  }
}

// Fun√ß√£o para buscar dados do sistema
async function analisarDadosDoSistema(userId: number, userName: string, leadContextCodLead?: string) {
  try {
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:5000';
    const headers = { 'Cookie': `user=${JSON.stringify({ id: userId })}` };
    
    console.log('‚ö° Iniciando busca paralela de dados...');
    
    // **PARALELIZA√á√ÉO: Buscar todos os dados simultaneamente**
    const [leadsData, funisData, parceirosData, produtosData, pedidosData] = await Promise.all([
      fetch(`${baseUrl}/api/leads`, { headers }).then(r => r.ok ? r.json() : []),
      fetch(`${baseUrl}/api/funis`, { headers }).then(r => r.ok ? r.json() : []),
      fetch(`${baseUrl}/api/sankhya/parceiros?page=1&pageSize=100`).then(r => r.ok ? r.json() : { parceiros: [] }),
      fetch(`${baseUrl}/api/sankhya/produtos?page=1&pageSize=100`).then(r => r.ok ? r.json() : { produtos: [] }),
      fetch(`${baseUrl}/api/sankhya/pedidos/listar?userId=${userId}`).then(r => r.ok ? r.json() : [])
    ]);

    const leads = Array.isArray(leadsData) ? leadsData : [];
    const funis = Array.isArray(funisData) ? funisData : [];
    const parceiros = Array.isArray(parceirosData.parceiros) ? parceirosData.parceiros : [];
    const produtos = Array.isArray(produtosData.produtos) ? produtosData.produtos : [];
    const pedidos = Array.isArray(pedidosData) ? pedidosData : [];

    // Buscar est√°gios de todos os funis em paralelo
    const estagiosPorFunil: Record<string, any[]> = {};
    const estagiosPromises = funis.map(async (funil) => {
      const estagiosData = await fetch(`${baseUrl}/api/funis/estagios?codFunil=${funil.CODFUNIL}`, { headers })
        .then(r => r.ok ? r.json() : []);
      estagiosPorFunil[funil.CODFUNIL] = Array.isArray(estagiosData) ? estagiosData : [];
    });
    await Promise.all(estagiosPromises);

    console.log(`‚úÖ Dados carregados: ${leads.length} leads, ${funis.length} funis, ${produtos.length} produtos`);

    // **ENRIQUECER LEADS: Limitar a 10 e remover lead do contexto se existir**
    let leadsParaEnriquecer = leads.slice(0, 10);
    
    // Se h√° um lead aberto no contexto, remov√™-lo da lista geral para evitar duplica√ß√£o
    if (leadContextCodLead) {
      leadsParaEnriquecer = leadsParaEnriquecer.filter(l => l.CODLEAD !== leadContextCodLead);
      console.log(`üîç Lead ${leadContextCodLead} removido da lista geral (j√° est√° no contexto)`);
    }

    const leadsEnriquecidos = await Promise.all(
      leadsParaEnriquecer.map(lead => enriquecerLead(lead, baseUrl, funis, estagiosPorFunil, parceiros, userId))
    );
    console.log(`‚úÖ ${leadsEnriquecidos.length} leads enriquecidos`);

    return {
      userName,
      leads: leadsEnriquecidos,
      funis: funis,
      estagiosPorFunil: estagiosPorFunil,
      parceiros: parceiros.slice(0, 15),
      produtos: produtos.slice(0, 15),
      pedidos: pedidos.slice(0, 10),
      totalLeads: leads.length,
      totalParceiros: parceirosData.total || parceiros.length,
      totalProdutos: produtosData.total || produtos.length,
      totalPedidos: pedidos.length
    };
  } catch (error) {
    console.error('Erro ao analisar dados:', error);
    return null;
  }
}

const SYSTEM_PROMPT = `Voc√™ √© um Assistente de Vendas Inteligente integrado em uma ferramenta de CRM/For√ßa de Vendas chamada Sankhya CRM.

SEU PAPEL E RESPONSABILIDADES:
- Ajudar vendedores a identificar oportunidades de vendas
- Sugerir a√ß√µes estrat√©gicas para fechar neg√≥cios
- Analisar leads e recomendar pr√≥ximos passos
- Identificar clientes potenciais com maior chance de convers√£o
- Sugerir produtos que podem interessar aos clientes
- Alertar sobre leads em risco ou oportunidades urgentes

DADOS QUE VOC√ä TEM ACESSO:
- Leads: oportunidades de vendas com informa√ß√µes sobre valor, est√°gio, parceiro associado
- Parceiros: clientes e prospects cadastrados no sistema
- Produtos: cat√°logo REAL de produtos com estoque atual (USE APENAS OS PRODUTOS FORNECIDOS NO CONTEXTO)
- Atividades: hist√≥rico de intera√ß√µes com leads
- Lead Atual: quando um lead espec√≠fico estiver aberto, voc√™ ter√° acesso completo aos seus dados detalhados (funil, est√°gio, valor, produtos, atividades, parceiro, √∫ltima intera√ß√£o)

‚ö†Ô∏è REGRA IMPORTANTE SOBRE PRODUTOS:
Voc√™ receber√° uma lista completa de produtos com suas quantidades em estoque.
NUNCA mencione produtos que n√£o estejam explicitamente listados nos dados fornecidos.
Se n√£o houver produtos na lista, informe que n√£o h√° produtos cadastrados no momento.

COMO VOC√ä DEVE AGIR:
1. Sempre analise os dados fornecidos antes de responder
2. Seja proativo em sugerir vendas e a√ß√µes comerciais
3. Identifique padr√µes e oportunidades nos dados
4. Use m√©tricas e n√∫meros concretos em suas an√°lises
5. Seja direto e focado em resultados de vendas
6. Priorize leads com maior valor e urg√™ncia
7. Sugira pr√≥ximos passos claros e acion√°veis
8. Quando um lead espec√≠fico estiver aberto, voc√™ DEVE responder APENAS com base nas informa√ß√µes daquele lead
9. Use TODAS as informa√ß√µes do contexto do lead: nome do funil, est√°gios, parceiro, produtos, atividades e √∫ltima intera√ß√£o
10. NUNCA invente ou assuma informa√ß√µes que n√£o est√£o explicitamente no contexto fornecido

FORMATO DAS RESPOSTAS:
- Use emojis para destacar informa√ß√µes importantes (üìä üí∞ üéØ ‚ö†Ô∏è ‚úÖ)
- Organize informa√ß√µes em listas quando relevante
- Destaque valores monet√°rios e datas importantes
- Seja conciso mas informativo

Sempre que o usu√°rio fizer uma pergunta, considere os dados do sistema dispon√≠veis para dar respostas contextualizadas e acion√°veis.`;

export async function POST(request: NextRequest) {
  try {
    const { message, history, leadContext } = await request.json();

    // Obter usu√°rio autenticado
    const cookieStore = await cookies();
    const userCookie = cookieStore.get('user');
    let userId = 0;
    let userName = 'Usu√°rio';
    
    if (userCookie) {
      try {
        const user = JSON.parse(userCookie.value);
        userId = user.id;
        userName = user.name || 'Usu√°rio';
      } catch (e) {
        console.error('Erro ao parsear cookie:', e);
      }
    }

    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

    // Montar hist√≥rico com prompt de sistema
    const chatHistory = [
      {
        role: 'user',
        parts: [{ text: SYSTEM_PROMPT }],
      },
      {
        role: 'model',
        parts: [{ text: 'Entendido! Sou seu Assistente de Vendas no Sankhya CRM. Estou pronto para analisar seus dados e ajudar voc√™ a vender mais. Como posso ajudar?' }],
      },
      ...history.map((msg: any) => ({
        role: msg.role === 'assistant' ? 'model' : 'user',
        parts: [{ text: msg.content }],
      }))
    ];

    // Adicionar contexto de dados APENAS no primeiro prompt do usu√°rio
    let messageWithContext = message;
    if (history.length === 0) {
      console.log('üîç Primeiro prompt detectado - Buscando dados do sistema...');
      
      // Extrair CODLEAD do leadContext se dispon√≠vel
      let leadContextCodLead: string | undefined;
      if (leadContext) {
        const match = leadContext.match(/ID do Lead:\s*(\d+)/);
        leadContextCodLead = match ? match[1] : undefined;
      }
      
      const dadosSistema = await analisarDadosDoSistema(userId, userName, leadContextCodLead);
      
      if (dadosSistema) {
        let leadContextoFormatado = '';
        
        // Adicionar contexto do lead se dispon√≠vel
        if (leadContext) {
          console.log('üìã Lead aberto - Adicionando contexto priorit√°rio');
          leadContextoFormatado = `
üéØ LEAD ABERTO (PRIORIDADE):
${leadContext}
---
`;
        }
        
        // **FORMATA√á√ÉO OTIMIZADA E CONCISA**
        messageWithContext = `${leadContextoFormatado}
üìä RESUMO: ${dadosSistema.totalLeads} leads | ${dadosSistema.totalParceiros} clientes | ${dadosSistema.totalProdutos} produtos | ${dadosSistema.totalPedidos} pedidos

üéØ LEADS PRINCIPAIS (${dadosSistema.leads.length}):
${dadosSistema.leads.map(l => `
‚Ä¢ ${l.NOME} (ID: ${l.CODLEAD}) | üí∞ R$ ${l.VALOR?.toLocaleString('pt-BR') || '0'}
  ‚Ü≥ ${l.NOME_FUNIL} ‚Üí ${l.NOME_ESTAGIO} | Venc: ${l.DATA_VENCIMENTO || 'N/A'}
  ${l.PARCEIRO ? `Cliente: ${l.PARCEIRO.nome}` : 'Sem cliente'}
  ${l.PRODUTOS?.length > 0 ? `Produtos: ${l.PRODUTOS.map(p => `${p.descricao} (${p.quantidade}x)`).join(', ')}` : 'Sem produtos'}
  ${l.ULTIMA_INTERACAO ? `√öltima: ${l.ULTIMA_INTERACAO.tipo} em ${new Date(l.ULTIMA_INTERACAO.data).toLocaleDateString('pt-BR')}` : 'Sem intera√ß√£o'}`
).join('\n')}

üì¶ PRODUTOS (${dadosSistema.produtos.length}):
${dadosSistema.produtos.map(p => `‚Ä¢ ${p.DESCRPROD} | Estoque: ${parseFloat(p.ESTOQUE || '0').toFixed(0)} un`).join('\n')}

PERGUNTA: ${message}`;
        console.log('‚úÖ Prompt otimizado gerado');
      }
    } else {
      console.log('üí¨ Prompt subsequente');
    }

    const chat = model.startChat({
      history: chatHistory,
      generationConfig: {
        maxOutputTokens: 1024, // Reduzido para respostas mais diretas e acion√°veis
      },
    });

    // Usar streaming com contexto
    const result = await chat.sendMessageStream(messageWithContext);

    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        try {
          for await (const chunk of result.stream) {
            const text = chunk.text();
            const data = `data: ${JSON.stringify({ text })}\n\n`;
            controller.enqueue(encoder.encode(data));
          }
          controller.enqueue(encoder.encode('data: [DONE]\n\n'));
          controller.close();
        } catch (error) {
          controller.error(error);
        }
      },
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error) {
    console.error('Erro no chat Gemini:', error);
    return new Response(JSON.stringify({ error: 'Erro ao processar mensagem' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}
